from parsita import lit, reg, rep, Parser, opt, Failure, until
from returns.result import Success

from tests.notebook_fixtures import *

r"""
 __  __            _       _
|  \/  |          | |     | |
| \  / | __ _ _ __| | ____| | _____      ___ __
| |\/| |/ _` | '__| |/ / _` |/ _ \ \ /\ / / '_ \
| |  | | (_| | |  |   < (_| | (_) \ V  V /| | | |
|_|  |_|\__,_|_|  |_|\_\__,_|\___/ \_/\_/ |_| |_|

Lessons about parsita.

1. When invoking a parser, you _must_ consume all the tokens until the EOD or you will get a failure
   You can do this with
   `{...} << whatever`
2. When you want to extract _one_ value out of a big text. You can say the following:
   parser_that_must_exist_around_it >> parser_that_follows >> another_parser << the_parser_you_care_about >> after_the_parser_you_care_about
   So:
   `{...} >> yes << whatever` => `Success<yes>`
3. Lambdas are evil. Do not use lambdas to create abstractions.
   While it may seem attractive to write a lambda to express a common pattern, this is not a good idea.
   The operators in parsita have specific meaning, and parsita is a language expressed with operators.
   When you write a function, the result of the operator is lost.
"""


def assert_parser_succeeds(parser: Parser, input_string: str, expected_output=None):
    result = parser.parse(input_string)
    match result:
        case Success(value):
            output = value
            if expected_output:
                assert expected_output == output
        case Failure(error):
            raise error
    assert type(result) is Success, result.failure()


any_char = reg(r'.') | lit("\n")
whatever = rep(any_char)
newline = lit('\n')

to_newline = reg(r'[^\n]+')

obsidian_tag = reg(r"#([a-z/])+")
frontmatter = opt(
    lit('---') >> newline >>
    lit("tags") >> lit(":\n") >> lit("- ") >> lit("'") >> obsidian_tag << lit("'") << rep(newline) <<
    lit("---") << rep(newline)
)
autogeneration_warning = lit("""> [!WARNING] **Do not modify** this file
> This file is automatically generated by Scrybble and will be overwritten whenever this file in synchronized.
> Treat it as a reference.""")
h1_tag = lit("# ")
h2_tag = lit("## ")
h3_tag = lit("### ")
h4_tag = lit("#### ")
h5_tag = lit("##### ")
h6_tag = lit("###### ")

@pytest.mark.markdown
@pytest.mark.parametrize("notebook", ["markdown_tags_document"], indirect=True)
def test_yaml_frontmatter_is_valid(notebook, remarks_document, obsidian_markdown):
    assert_parser_succeeds(frontmatter << whatever, obsidian_markdown, ["#remarkable/obsidian"])

@pytest.mark.markdown
@pytest.mark.parametrize("notebook", ["highlights_document"], indirect=True)
def test_highlights_are_available_in_markdown(notebook, remarks_document, obsidian_markdown):
    # yellow marker
    smart_highlight_one = "numbers may be described briefly as the real numbers whose expressions as a decimal are calculable by finite means"
    # blue marker
    smart_highlight_two = "theory of functions"
    # green marker
    smart_highlight_three = "According to my definition, a number is computable if its decimal can be written down by a machine."
    # pink marker
    smart_highlight_four = "In particular, I show that certain large classes of of numbers are computable."
    # grey marker
    # smart_highlight_five = "Although the class of computable numbers is so great, and in many ways similar to the class of real numbers, it is nevertheless enumerable."

    assert_parser_succeeds(until(smart_highlight_one) >> smart_highlight_one << whatever, obsidian_markdown, smart_highlight_one)
    assert_parser_succeeds(until(smart_highlight_two) >> smart_highlight_two << whatever, obsidian_markdown, smart_highlight_two)
    assert_parser_succeeds(until(smart_highlight_three) >> smart_highlight_three << whatever, obsidian_markdown, smart_highlight_three)
    assert_parser_succeeds(until(smart_highlight_four) >> smart_highlight_four << whatever, obsidian_markdown, smart_highlight_four)
    # assert_parser_succeeds(until(smart_highlight_five) >> smart_highlight_four << whatever, obsidian_markdown, smart_highlight_five)
